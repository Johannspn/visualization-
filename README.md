# -*- coding: utf-8 -*-
"""NN for several image.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LjvYDUeFDOixOTvmFTNLZMhHErKUYfN7
"""

#### Libraries
# Standard library
import random
import numpy as np
import sys
import time
import numpy as np
from random import seed
from sklearn.preprocessing import StandardScaler
from keras.datasets import mnist
from matplotlib import pyplot as plt

(x_train, y_train), (x_test, y_test) = mnist.load_data()
X_scale = StandardScaler()
train=[]
test=[]

for i in range(60000):
    inpx=np.zeros(shape=(28, 28))
    inpy=np.zeros(shape=(10 , 1))
    
    f=X_scale.fit_transform(x_train[i])
    inpx=f.reshape(784,1)
    inpy[y_train[i]]=1
    train.append((inpx, inpy))
    
for i in range(10000):
    inpx=np.zeros(shape=(28, 28))
    #inpy=np.zeros(shape=(10 , 1))
    
    f=X_scale.fit_transform(x_test[i])
    inpx=f.reshape(784,1)
    test.append((inpx, y_test[i]))    

#number of hidden lyer nuerons
hl=50
#learning rate
lr=0.2
#number of Epochs
epn=50

net=[784, hl, 10]

l=len(net)-1



#making neural network and initialization 
#l

w=[]
b=[]
dw=[]
db=[]
for i in range(l):
    w.append(np.random.randn(net[i+1],net[i]))
    b.append(np.random.randn(net[i+1],1))
    dw.append(np.zeros(shape=(net[i+1],net[i])))
    db.append(np.zeros(shape=(net[i+1],1)))

#neural network functions
def forward(inp):
    forwardResult=[]
    #forwardResult.append(inp)
    forwardResult.append(sigmoid(np.dot(w[0],inp)+b[0]))
    for i in range(1,l):
        #print(i)
        forwardResult.append(sigmoid(np.dot(w[i],forwardResult[i-1] )+b[i]))
    return forwardResult

def bp(inp, fr, outp):
    er=outp-fr[l-1]
    for i in range(l-1,-1,-1):
        if(i==0):
            delta=er*sp(fr[i])
            db[i]=delta
            dw[i]=np.dot(delta, inp.T)
        else:
            delta=er*sp(fr[i])
            db[i]=delta
            dw[i]=np.dot(delta, fr[i-1].T)
            er=np.dot(w[i].T, delta)
def update():
    for i in range(l):
        w[i]=w[i]+(lr*dw[i])
        b[i]=b[i]+(lr*db[i])

def predict(inp):
    result=forward(inp)
    return result.argmax()
    
def model_acc(test):
    Tr=0
    Fal=0
    for i in range(len(test)):
        fr=forward(test[i][0])
        if(fr[1].argmax()==test[i][1]):
            Tr+=1
        else:
            Fal+=1
    acc=100*Tr/(Tr+Fal)
    return acc

def sp(z):
    return (z)*(1-(z))

def sigmoid(z):
    """The sigmoid function."""
    return 1.0/(1.0+np.exp(-z))
def model_training(tr, ep):
    print("epoch : ")
    #print(len(tr[0]))
    for j in range(ep):
        sys.stdout.write("\r{0}".format(j+1))
        np.random.shuffle(tr)
        for i in range(len(tr)):
            fr=forward(tr[i][0])
            bp(tr[i][0], fr, tr[i][1])
            update()  
    print("\nend of training")

model_training(train, epn)

print("model acc= ",model_acc(test))
